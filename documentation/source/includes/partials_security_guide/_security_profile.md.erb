## Perfil de segurança

### Sobre os padrões de perfil de segurança de API.
É necessário que os participantes do Open Banking adotem padrões de autenticação e autorização para as APIs e *End-Users*, utilizando frameworks e mecanismos aprovados pelo mercado, garantindo assim, a integridade, a confidencialidade e a disponibilidade dos dados.

Conjunto de referências normativas adotadas pelo Open Banking:

|Referência|Link|
|---------|---------|      
|FAPI-RW - Financial-grade API - Part 2: Read and Write API Security Profile|<a href='https://openid.net/specs/openid-financial-api-part-2.html'target="_blank"> https://openid.net/specs/openid-financial-api-part-2.html</a>|
|CIBA (opcional) - OpenID Connect Client Initiated Backchannel Authentication Flow - Core 1.0|<a href='https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html'target="_blank"> https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html</a>|
|JSON - The JavaScript Object Notation (JSON) Data Interchange Format|<a href='https://tools.ietf.org/html/rfc8259'target="_blank"> https://tools.ietf.org/html/rfc8259</a>|
|JWT - JSON Web Token (JWT)|<a href='https://tools.ietf.org/html/rfc7519'target="_blank"> https://tools.ietf.org/html/rfc7519</a>|
|JWS - JSON Web Signature|<a href='https://tools.ietf.org/html/rfc7797'target="_blank"> https://tools.ietf.org/html/rfc7797</a>|
|MTLS - OAuth 2.0 Mutual TLS Client, Authentication and Certificate Bound, Access Tokens|<a href='https://tools.ietf.org/html/draft-ietf-oauth-mtls-17'target="_blank"> https://tools.ietf.org/html/draft-ietf-oauth-mtls-17</a>|
|OAUTH2 - The OAuth 2.0 Authorization Framework|<a href='https://tools.ietf.org/html/rfc6749'target="_blank"> https://tools.ietf.org/html/rfc6749</a>|
|OIDC - OpenID Connect Core 1.0 incorporating errata set 1|<a href='http://openid.net/specs/openid-connect-core-1_0.html'target="_blank"> http://openid.net/specs/openid-connect-core-1_0.html</a>|
|RFC7009 - OAuth 2.0 Token Revocation|<a href='https://tools.ietf.org/html/rfc7009'target="_blank"> https://tools.ietf.org/html/rfc7009</a>|
|RFC7662 - OAuth 2.0 Token Introspection|<a href='https://tools.ietf.org/html/rfc7662'target="_blank"> https://tools.ietf.org/html/rfc7662</a>|
|RFC6750 - The OAuth 2.0 Authorization Framework: Bearer Token Usage|<a href='https://tools.ietf.org/html/rfc6750'target="_blank"> https://tools.ietf.org/html/rfc6750</a>|
|RFC7591 - OAuth 2.0 Dynamic Client Registration Protocol|<a href='https://tools.ietf.org/html/rfc7591'target="_blank"> https://tools.ietf.org/html/rfc7591</a>|

Para melhor entendimento do *FAPI-Read and Write API Profile* e do *CIBA-Financial-grade API: Client Initiated Backchannel Authentication Profile*,  é preciso ter conhecimento sobre OAuth2 e OpenID Connect.

### OAuth 2.0

OAuth 2.0 é um framework de autorização que habilita um aplicativo a obter acesso limitado para um serviço de terceiro, introduzindo uma camada de autorização e segmentando as funções do *client*.
Ao invés de utilizar credenciais fornecidas pelo proprietário do recurso, o *client* recebe um *Access Token*, contendo o escopo do acesso, tempo de vida, entre outros atributos. Os *Access Tokens* são emitidos para *clients* terceiros por um servidor de autorização com a aprovação do proprietário do recurso. 

O OAuth 2.0, define 4 papéis. 

* *End-User*: Uma entidade capaz de conceder acesso a recursos protegidos. Quando o proprietário do recurso é um usuário, ele provê o nível de acesso, limitando o escopo de autorização (leitura ou escrita).  
* *Resource Server*: Servidor que hospeda os recursos protegidos, capaz de aceitar e responder a solicitações de recursos protegidos utilizando tokens de acesso.
* *Client*: Um aplicativo que faz solicitações a recursos protegidos em nome do proprietário do recurso, com a sua autorização. 
* *Authorization Server*: É o servidor que emite tokens de acesso ao *client*, após autenticar com sucesso e obter autorização do *End-User*. 


### Tokens 

O OAuth 2.0 faz o uso de diversos tokens, entre eles, o *access token*, *refresh token* e *Authorization "code"*.

* *Access token*: Um token de acesso é utilizado por um *client* para acessar um recurso, geralmente possuem ciclo de vida curto (minutos ou horas), sendo consumidos durante uma sessão. O *Access token* indica que o client está autorizado a consumir um recurso protegido, respeitando os *scopes* para qual o token foi emitido. O token pode ser renovado através de um *refresh token*. O tipo de *Access Token* será o *"Bearer" OAuth Access Token*, referenciado em <a href='https://tools.ietf.org/html/rfc6750'target="_blank">[RFC 6750]</a>.
* *Refresh token*: Representa uma autorização de longa duração de um *client*. Esses tokens são trocados entre o *client* e o *Authorization Server* e são utilizados para obter (“atualizar”) novos tokens de acesso. 
* *Authorization code*: É um código de autorização que representa o resultado do processo de autorização bem sucedido do usuário final e é utilizado pelo *client* para obter acesso e atualizar status dos tokens. 

É necessário a implementação de um *endpoint* adicional no *Authorization Server* que possibilita a revogação do *Access Token* e do *Refresh Token*. Um *request* de revogação invalidará um ou mais Tokens (se aplicável), baseados na mesma concessão de acesso, conforme <a href='https://tools.ietf.org/html/rfc7009'target="_blank">[RFC 7009]</a>.
Também será adotado o *OAuth Token Introspection* que define um método para um recurso protegido consultar um *Authorization Server* sobre o estado e os metadados de um Token, conforme <a href='https://tools.ietf.org/html/rfc7662'target="_blank">[RFC 7662]</a>.
Devido a ampla aplicação do uso do OAuth 2.0, as melhores práticas de segurança do OAuth 2.0 estão em constate atualização e podem ser consultadas neste endereço <a href='https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16'target="_blank">https://tools.ietf.org/html/draft-ietf-oauth-security-topics-16</a>.
    
Início do fluxo de uma API com a obtenção de um *Access Token*.

<img class='lazy' src='images/loading.gif' data-src='images/security/Signed_JWT_Flow.png'/>

Diagrama – Obtendo um *Access Token*.

1.	Estabelece conexão TLS 1.2 entre o usuário e o *client*.
2.	Estabelece conexão mTLS 1.2 entre o *client* e o *Authorization Server*.
3.	Efetua um POST com as credenciais de autenticação do *client* e o escopo da solicitação.
4.	Valida a autenticação de credenciais do *client*, o escopo e o certificado SSL.
5.	Devolve o *Access Token* com a mensagem HTTP 200 (OK).
6.	Estabelece conexão mTLS 1.2 entre o *Client* e o *Resource Server*.
7.	Efetua um POST com o *Access Token* e o escopo.
8.	Valida o *Access Token*, o escopo e o certificado.
9.	Resposta com a mensagem HTTP 201 com o ID da transação.
10.	Início do *Hybrid Flow*.


### OpenID Connect (OIDC)

O OpenID Connect é uma camada de identidade sobre o protocolo OAuth 2.0, que permite a identificação de um usuário final com base na autenticação realizada por um *Authorization Server*. 
OpenID Connect permite uma grande variedade de tipos de *clients*, sendo, *clients* Web, *clients* móveis e JavaScript, oferecendo suporte a recursos opcionais, como criptografia de dados de identidade, descoberta de provedores de OpenID e gerenciamento de sessão.
Existem três papéis envolvendo uma solução de OIDC: 

* *End-User*: É o sujeito a ser autenticado.  
* OpenID Provider - OP: O provedor OpenID é um servidor de autorização OAuth 2.0 que implementa OIDC e pode autenticar um usuário e retornar *claims* sobre o usuário autenticado e o evento de autenticação para uma parte confiável, geralmente um aplicativo.
* *Relying Party* – RP: Um *client* OAuth 2.0 que delega a autenticação de usuários para um provedor de OpenID e solicita *claims* sobre o usuário do provedor OpenID, geralmente denominado, *client*.
 
### ID Token 

O OIDC utiliza o *authorization code*, *access token* e *refresh token* descrito na seção anterior sobre OAuth e define um outro tipo de Token, o *ID Token*. 

* *ID Token*: Um token utilizado para transmitir *claims* sobre um evento de autenticação e um usuário autenticado *(End-user)* para um *client*. Tokens de identificação são codificados em JSON Web Token (JWT) e deve estar em conformidade com a LGPD.

<span style="background-color:black">
<span style="color:white">
{<br>
  "iss": "http://YOUR_DOMAIN/",<br>
  "sub": "xpto|123456",<br>
  "aud": "YOUR_CLIENT_ID",<br>
  "exp": 1311281970,<br>
  "iat": 1311280970,<br>
  "id": 1234567,<br>
}<br>
</span>
</span>

*UserInfo Endpoint*: Retorna *claims* sobre um usuário autenticado. Chamar o *endpoint* requer um *Access Token* e as *claims* retornadas são regidos pelo *Access Token*.
Exemplo de resposta bem-sucedida  contendo um *ID Token* assinado:
HTTP/1.1 200 OK
Content-Type: application/json
Cache-Control: no-store
Pragma: no-cache

<span style="background-color:black">
<span style="color:white">
{<br>
   "access_token": "SlAV32hkKG",<br>
   "token_type": "Bearer",<br>
   "refresh_token": "8xLOxBtZp8",<br>
   "expires_in": 3600,<br>
   "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc<br>
     yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5<br>
     NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ<br>
     fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz<br>
     AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q<br>
     Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ<br>
     NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd<br>
     QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS<br>
     K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4<br>
     XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg"<br>
}<br>
</span>
</span>

### JWT

O formato JWT (JSON Web Token) é projetado para transmitir *claims* entre duas partes. O JWT consiste em um *Header*, um *payload* e uma assinatura. O cabeçalho do *ID Token* contém informações sobre o tipo de objeto (JWT) e o algoritmo de assinatura utilizado para proteger a integridade dos *claims* do *payload*. O algoritmo de assinatura exigido é o PS256 (RSASSA-PSS utilizando SHA-256 e MGF1 com SHA-256). A seção do *payload* contém as *claims* sobre um usuário e o evento de autenticação. A seção de assinatura contém uma assinatura digital com base no *payload* do *ID Token* e uma chave secreta conhecida pelo provedor OpenID. 

O JWT é formado por três seções: *Header, Payload* e *Signature*.
O *Header* contém somente a informação tipo e algoritmo:

<span style="background-color:black">
<span style="color:white">
{<br>
    "typ": "JWT",<br>
    "alg": " PS256"<br>
}<br>
</span>
</span>

### *Payload*

O *Payload* é um objeto JSON com as *Claims* da entidade tratada, normalmente o usuário autenticado.
*Claims* são informações afirmadas sobre um sujeito, por exemplo um *ID Token*, pode conter uma *claim* chamada *name* que afirma que o usuário autenticado é quem diz ser. Em um JWT uma claim aparece como um par nome/valor em que o nome é sempre uma *string* e o valor pode conter qualquer conteúdo JSON.
Essas *claims* podem ser de 3 tipos:
*Reserved claims*: São *claims* definidas pela especificação do JWT e contém atributos não obrigatórios (mais recomendados) que são usados na validação do token pelos protocolos de segurança das APIs. É possível verificar a lista completa de *Reserved Claims* em [IANA JSON Web Token Claims Registry].

<span style="background-color:black">
<span style="color:white">
sub (subject) = Entidade à quem o token pertence, normalmente o ID do usuário;<br>
iss (issuer) = Emissor do token;<br>
exp (expiration) = Timestamp de quando o token irá expirar;<br>
iat (issued at) = Timestamp de quando o token foi criado;<br>
aud (audience) = Destinatário do token, representa a aplicação que irá usá-lo.<br>
</span>
</span>


*Public claims*: atributos utilizados nas aplicações. Normalmente armazenamos as informações do usuário autenticado na aplicação.

<span style="background-color:black">
<span style="color:white">
name<br>
roles<br>
permissions<br>
</span>
</span>

*Private claims*: são *claims* personalizadas e contém atributos definidos  para compartilhar informações entre aplicações.

<span style="background-color:black">
<span style="color:white">
{<br>
    "sub": "1234567890",<br>
    "name": "Jose Doe"<br>
    "admin": "true"<br>
}<br>
</span>
</span>

Conjunto de *claims* para um *ID Token* do Open Banking:

<span style="background-color:black">
<span style="color:white">
{<br>
" iss": Emissor do token<br>
"sub": Identificador único do subject<br>
"openbanking_intent_id": Intent ID da solicitação<br>
"aud": Público alvo para o qual o ID Token é destinado (deve incluir o Client ID)<br>
"exp": Data/hora de expiração do token<br>
"iat": Data/hora de emissão do token<br>
"auth_time": Data/hora de autenticação do End-user<br>
"nonce": Valor string que associa uma sessão do cliente com um ID Token usado para ajudar na mitigação de ataques de replay<br>
"acr": Authentication Context Class Reference<br>
"amr": Authentication Methods References<br>
"azp": Authorized party<br>
"s_hash": State hash value<br>
"at_hash": Access Token hash value<br>
"c_hash": Code hash value<br>
}<br>
</span>
</span>



### Assinatura

A assinatura é o *header* e o *payload* criptografados com um *secret*.

<span style="background-color:black">
<span style="color:white">
PS256-RSASSA-PSS(<br>
base64UrlEncode(header) + "." +<br>
base64UrlEncode(payload),<br>
secret)<br>
</span>
</span>

Para obter o token JWT, as três seções *(header, payload, signature)* são codificadas com Base64-URL e unidas por pontos.

IMAGEM

Este token JWT deve ser enviado no cabeçalho *Authentication* HTTP usando o esquema *Bearer*. O conteúdo do cabeçalho deve seguir este formato:

Authorization: Bearer <token>


### Fluxo OpenID Connect (OIDC) 

O OpenID Connect define os seguintes fluxos: 

* *Authorization Code Flow*: Para autenticar um usuário, o *client* redireciona o usuário para um provedor de OpenID. O provedor OpenID autentica o usuário e redireciona o usuário de volta para o *client* com um código de autorização. O aplicativo usa o código de autorização para obter um *ID Token*, *Access Token* e, opcionalmente, um *Refresh Token* do *endpoint* do provedor OpenID. 
* *Implicit flow*: Todos os tokens são retornados pelo *endpoint* de autorização, o *Endpoint* de Token não é utilizado, esse tipo de fluxo é usado principalmente por *Clients* implementados em um navegador utilizando uma linguagem de script. O *Access Token* e o *ID Token* são devolvidos diretamente ao *Client*, que pode expô-los ao usuário final e aos aplicativos que têm acesso 
* *Hybrid flow*: O *Hybrid Flow*, combina elementos do *Authorization Code Flow* e *Implicit Flow*, esse modelo permite retornar um *ID Token* e um *Authorization Code* como uma resposta ao *front-end* do *client*, deixando o *backend* obter um *Access Token* e opcionalmente um *Refresh Token* do *endpoint* de token utilizando o *Authorization Code*. Esse padrão de autenticação foi escolhido como mandatório pelo Open Banking e pode ser observado no diagrama a seguir. 

Diagrama - Fluxo *Hybrid Flow*

1.	Usuário acessa o aplicativo e faz requisições ao *Client*. 
2.	*Client* redireciona a requisição de autenticação ao *Authorization Server*. 
3.	O *Authorization Server* interage com o usuário com a requisição de autenticação e o consentimento sobre o escopo. 
4.	Usuário efetua a autenticação e provê o consentimento, o *Authorization Server* cria ou atualiza uma sessão para o usuário. 
5.	*Authorization Server* direciona o *End-User* de volta ao *client* com um código de autorização e, dependendo do tipo da resposta, com parâmetros adicionais. 
6.	O *Client* solicita uma resposta ao *Authorization Server* com o código de autorização para obter os demais tokens. 
7.	O *Authorization Server* responde com o *ID Token* e um *Access Token*. 
8.	O *Client* valida o *ID Token* e busca o *Subject Identifier* do *End-User*. O *Authorization Server* deve suportar *request objects* conforme especificado na seção 6.1 (Request Object) do OIDC. 


## Financial-grade API (FAPI)


Financial-grade API, o FAPI, é uma especificação técnica desenvolvida pelo Grupo de Trabalho Financial-grade API da OpenID Foundation. Ele utiliza OAuth 2.0 e OpenID Connect (OIDC) como sua base e define requisitos técnicos adicionais para o setor financeiro e outros setores que exigem maior segurança.

IMAGEM AQUI

### FAPI: Read and Write API Security Profile

É obrigatório o uso do perfil de segurança FAPI-Financial-grade API: Read and Write API Security Profile, referenciado no endereço: https://openid.net/specs/openid-financial-api-part-2-wd-06.html .

### FAPI: CIBA-Client Initiated Backchannel Authentication Profile

A autenticação pelo CIBA fornece um fluxo desacoplado, possibilitando autorizar um pagamento por exemplo em um terminal de ponto de venda ou em um posto de combustível.
O perfil de segurança CIBA: Client Initiated Backchannel Authentication Profle será opcional pelos participantes do Open Banking, referenciado no endereço: https://openid.net/specs/openid-financial-api-ciba.html .
